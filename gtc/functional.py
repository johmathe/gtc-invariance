import torch
import numpy as np
import scipy as sc


def triple_correlation(x):
    d = x.shape[0]
    TC = torch.zeros((d, d))
    for i in range(d):
        for j in range(d):
            for k in range(d):
                TC[j, k] += x[i] * x[(i - j) % d] * x[(i - k) % d]
    return TC


def autocorrelation(x):
    d = x.shape[0]
    AC = torch.zeros((d))
    for i in range(d):
        for j in range(d):
            AC[j] += x[i] * x[(i - j) % d]
    return AC


def triple_correlation_batch(X):
    all_TCs = []
    for x in X:
        all_TCs.append(triple_correlation(x))
    return torch.stack(all_TCs)


def triple_correlation_group(x, cayley_table):
    N = cayley_table.shape[0]
    elements = np.arange(N)
    TC = torch.zeros((N, N))
    for i in range(N):
        for j in range(N):
            for k in range(N):
                g = elements[i]
                g1 = elements[j]
                g2 = elements[k]
                gg1 = cayley_table[g, g1]
                gg2 = cayley_table[g, g2]
                TC[j, k] += x[g] * x[gg1] * x[gg2]
    return TC


def get_cayley_table(group):
    elements = [x._element for x in group.elements]
    n = len(elements)
    cayley_table = np.zeros((n, n), dtype=int)
    for i, e1 in enumerate(elements):
        for j, e2 in enumerate(elements):
            combined = group._combine(e1, e2)
            for k, check in enumerate(elements):
                if group._equal(combined, check):
                    break
            cayley_table[i, j] = k
    return cayley_table


def triple_correlation_group_vectorized_batch(x, cayley_table):
    b, k, d = x.shape
    x = x.reshape((b * k, d))
    nexts = x[:, cayley_table]
    mult = x.unsqueeze(1) * x[:, cayley_table.swapaxes(0, 1)]
    TC = torch.bmm(mult, nexts)
    TC = TC.reshape((b, k, d, d))
    return TC


def first_last_cb(n, end=False):
    epst = 100 * np.finfo(np.float64).eps
    A = givens(2 * np.pi / n)
    B = givens(2 * np.pi / n)
    S = sc.linalg.schur(np.kron(A, B))
    list = []
    for i in range(4):
        if np.abs(np.abs(S[0][i, i]) - 1) < epst:
            list.append(i)
        elif S[0][i + 1, i] < 0:
            S[1][:, i : i + 2] = S[1][:, np.array([i + 1, i])]
    return torch.tensor(S[1], requires_grad=False), torch.tensor(
        list, dtype=int, requires_grad=False
    )


def clebsch_gordan(label_1, label_2, n):
    indices = torch.tensor([0, 0], requires_grad=False)
    A = givens(2 * np.pi * label_1 / n)
    B = givens(2 * np.pi * label_2 / n)
    S = sc.linalg.schur(np.kron(A, B))
    indices[0] = int(
        np.arccos(S[0][0, 0]) * n / (2 * np.pi)
    )  # These are the irreps generated by label_1\otimes label_2
    indices[1] = int(np.round(np.arccos(S[0][2, 2]) * n / (2 * np.pi), decimals=1))
    for i in (0, 2):
        if S[0][i + 1, i] < 0:
            S[1][:, i : i + 2] = S[1][:, np.array([i + 1, i])]
    return torch.tensor(S[1], requires_grad=False), indices


def givens(omega):
    return np.array([[np.cos(omega), -np.sin(omega)], [np.sin(omega), np.cos(omega)]])


def buildFplus(l, fhat, n, end=False):
    t = 2
    Fplus = torch.zeros(4, 4)
    if end == True:
        t = int(np.floor((n - 1) / 2)) - 1
        Fplus[l[0], l[0]] = fhat[0, 1, 0]
        Fplus[l[1], l[1]] = fhat[1, 1, 0]
    else:
        Fplus[l[0], l[0]] = fhat[0, 0, 0]
        Fplus[l[1], l[1]] = fhat[1, 0, 0]

    if l[1] - l[0] == 1:
        if l[0] == 0:
            Fplus[2:, 2:] = fhat[..., t]
        else:
            Fplus[0:2, 0:2] = fhat[..., t]
    else:
        Fplus[1:3, 1:3] = fhat[..., t]
    return Fplus


def build_Fplus_vectorized(l, fhat, n, end=False):
    t = 2
    b, c = fhat.shape[:2]
    Fplus = torch.zeros(b, c, 4, 4)
    if end == True:
        t = int(np.floor((n - 1) / 2)) - 1
        Fplus[:, :, l[0], l[0]] = fhat[:, :, 0, 1, 0]
        Fplus[:, :, l[1], l[1]] = fhat[:, :, 1, 1, 0]
    else:
        Fplus[:, :, l[0], l[0]] = fhat[:, :, 0, 0, 0]
        Fplus[:, :, l[1], l[1]] = fhat[:, :, 1, 0, 0]

    if l[1] - l[0] == 1:
        if l[0] == 0:
            Fplus[:, :, 2:, 2:] = fhat[..., t]
        else:
            Fplus[:, :, 0:2, 0:2] = fhat[..., t]
    else:
        Fplus[:, :, 1:3, 1:3] = fhat[..., t]
    return Fplus
